/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package gameterminal;

import java.awt.event.KeyEvent;
import com.mapgenerator.*;
import java.util.ArrayList;
import javax.swing.JOptionPane;

/**
 *
 * Ross Reid
 */
public class GameTerminal extends javax.swing.JFrame implements Runnable {

    /**
     * Creates new form GameTerminal
     */
    public GameTerminal() {

        maxHP = hp = 10;
        gold = 75;
        maxEnergy = energy = 10;

        initComponents();
        setVisible(true);
        setLocationRelativeTo(null);
        cmdsHistory = new ArrayList<>();
        mg = new MapGenerator();
        height = mg.getHeight();
        width = mg.getWidth();
        mg.genMap();
        for (int i = 0; i < Rng.rand(2, 20); i++) {
            mg.genDoors();
        }

        // Generate corridor 
        if (mg.doors.isEmpty()) {
            System.out.println("Error: No doors generated!");
        } else {
            for (int i = 0; i < mg.doors.size(); i++) {
                mg.genCorridor(i);
            }
        }
        map = new String[height][width];
        playerName = JOptionPane.showInputDialog(rootPane, "Enter your name hero!");
        nameLbl.setText(playerName);
        hpValLbl.setText(hp + "/" + maxHP);
        goldValLbl.setText("" + gold);
        energyValLbl.setText(energy + "/" + maxEnergy);
        createMapCopy();
        Door temp = mg.doors.get(1);
        plyrX = temp.getX();
        plyrY = temp.getY();
        map[plyrX][plyrY] = mg.getPLAYER();
        placeEnemies();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        console = new javax.swing.JTextArea();
        nameLbl = new javax.swing.JLabel();
        hpLbl = new javax.swing.JLabel();
        hpValLbl = new javax.swing.JLabel();
        goldLbl = new javax.swing.JLabel();
        goldValLbl = new javax.swing.JLabel();
        energyLbl = new javax.swing.JLabel();
        energyValLbl = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        console.setEditable(false);
        console.setColumns(20);
        console.setFont(new java.awt.Font("Courier New", 0, 13)); // NOI18N
        console.setRows(5);
        console.setAutoscrolls(false);
        console.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                consoleKeyPressed(evt);
            }
        });

        nameLbl.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        nameLbl.setText("NAME");

        hpLbl.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        hpLbl.setText("HP: ");

        hpValLbl.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        hpValLbl.setText("VALUE");

        goldLbl.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        goldLbl.setText("Gold:");

        goldValLbl.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        goldValLbl.setText("VALUE");

        energyLbl.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        energyLbl.setText("Energy:");

        energyValLbl.setFont(new java.awt.Font("Tahoma", 0, 13)); // NOI18N
        energyValLbl.setText("VALUE");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(console, javax.swing.GroupLayout.PREFERRED_SIZE, 797, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(nameLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(hpLbl)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(hpValLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(energyLbl)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(energyValLbl)
                        .addGap(18, 18, 18)
                        .addComponent(goldLbl)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(goldValLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(296, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(console, javax.swing.GroupLayout.PREFERRED_SIZE, 685, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(nameLbl)
                    .addComponent(hpLbl)
                    .addComponent(hpValLbl)
                    .addComponent(energyLbl)
                    .addComponent(energyValLbl)
                    .addComponent(goldLbl)
                    .addComponent(goldValLbl))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void consoleKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_consoleKeyPressed
        int key = evt.getKeyCode();
        switch (key) {
            case KeyEvent.VK_UP:
                if (evt.isControlDown()) {
                    dig('u');
                } else {
                    move('u');
                }
                break;
            case KeyEvent.VK_DOWN:
                if (evt.isControlDown()) {
                    dig('d');
                } else {
                    move('d');
                }
                break;
            case KeyEvent.VK_LEFT:
                if (evt.isControlDown()) {
                    dig('l');
                } else {
                    move('l');
                }
                break;
            case KeyEvent.VK_RIGHT:
                if (evt.isControlDown()) {
                    dig('r');
                } else {
                    move('r');
                }
                break;
        }
    }//GEN-LAST:event_consoleKeyPressed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GameTerminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GameTerminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GameTerminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GameTerminal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        GameTerminal gt = new GameTerminal();
        gt.printMap();
        // Thread t = new Thread(gt);
        // t.start();
        // Printing out the map 
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextArea console;
    private javax.swing.JLabel energyLbl;
    private javax.swing.JLabel energyValLbl;
    private javax.swing.JLabel goldLbl;
    private javax.swing.JLabel goldValLbl;
    private javax.swing.JLabel hpLbl;
    private javax.swing.JLabel hpValLbl;
    private javax.swing.JLabel nameLbl;
    // End of variables declaration//GEN-END:variables
    // Initializing main variables 
    MapGenerator mg;
    ArrayList<String> cmdsHistory;
    ArrayList<Path> paths; 
    int height = 0;
    int width = 0;
    String playerName;
    String map[][];
    String originalMap[][];
    String wall = MapGenerator.WALL;
    String door = MapGenerator.DOOR;
    String path = MapGenerator.PATH;
    String space = MapGenerator.SPACE;
    String player = MapGenerator.PLAYER;
    String shadow = MapGenerator.SHADOW;
    String dugup = MapGenerator.DUGUP;
    String enemy = MapGenerator.ENEMY;
    int plyrX = 0;
    int plyrY = 0;
    boolean canDig = true;
    // Stats
    int energy;
    int maxEnergy;
    int gold;
    int hp;
    int maxHP;

    // Gold loot generator
    private void digLoot() {
        int value = 0; // temp variable local scope
        double x = Math.random();
        if (x > 0.7 && x < 0.8) {
            value = (int) Math.ceil(Math.random() * 5); // 0.1 * 5 = 0.5 => 1 gold || 0.25 * 5 = 1.25 => 2 gold
            JOptionPane.showMessageDialog(rootPane, "You have found " + value + " gold");
            gold += value; // update global gold
            goldValLbl.setText("" + gold); // refresh label
        }
    }

    // Generating Map 
    private void printMap() {
        for (int i = 0; i < height; i++) { // row
            for (int j = 0; j < width; j++) { // col
                if ((i < plyrX - 5) || (i > plyrX + 5) || (j < plyrY - 9) || (j > plyrY + 9)) {
                    if (j != width - 1) {
                        console.append(shadow);
                    } else {
                        console.append(shadow + "\n");
                    }
               } else {
                    if (j != width - 1) {
                        console.append(map[i][j]);
                    } else {
                        console.append(map[i][j] + "\n");
                    }
                }
            }
        }
    }

    private void createMapCopy() {
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                map[i][j] = mg.map[i][j];
            }
        }
    }

    private void dig(char direction) {
        String message = "You cannot dig it!";
        if (direction == 'u') {
            if (map[plyrX - 1][plyrY].equals(wall)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (!map[plyrX - 1][plyrY].equals(path) && !map[plyrX - 1][plyrY].equals(dugup)) {
                if (energy > 0 && canDig == true) {
                    plyrX = plyrX - 1;
                    console.setText("");
                    mg.map[plyrX][plyrY] = dugup;
                    createMapCopy();
                    printMap();
                    digLoot();
                    energy = energy - 2;
                    energyValLbl.setText(energy + "/" + maxEnergy);
                } else {
                    JOptionPane.showMessageDialog(rootPane, "You can't dig anymore, take a rest!"); // implement turn-based env.
                    canDig = false;
                }
            }
        } else if (direction == 'd') {
            if (map[plyrX + 1][plyrY].equals(wall)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (!map[plyrX + 1][plyrY].equals(path) && !map[plyrX + 1][plyrY].equals(dugup)) {
                if (energy > 0 && canDig == true) {
                    plyrX = plyrX + 1;
                    console.setText("");
                    mg.map[plyrX][plyrY] = dugup;
                    createMapCopy();
                    printMap();
                    digLoot();
                    energy = energy - 2;
                    energyValLbl.setText(energy + "/" + maxEnergy);
                } else {
                    JOptionPane.showMessageDialog(rootPane, "You can't dig anymore, take a rest!"); // implement turn-based env.
                    canDig = false;
                }
            }
        } else if (direction == 'l') {
            if (map[plyrX][plyrY - 1].equals(wall)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (!map[plyrX][plyrY - 1].equals(path) && !map[plyrX][plyrY - 1].equals(dugup)) {
                if (energy > 0 && canDig == true) {
                    plyrY = plyrY - 1;
                    console.setText("");
                    mg.map[plyrX][plyrY] = dugup;
                    createMapCopy();
                    printMap();
                    digLoot();
                    energy = energy - 2;
                    energyValLbl.setText(energy + "/" + maxEnergy);
                } else {
                    JOptionPane.showMessageDialog(rootPane, "You can't dig anymore, take a rest!"); // implement turn-based env.
                    canDig = false;
                }
            }
        } else if (direction == 'r') {
            if (map[plyrX][plyrY + 1].equals(wall)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (!map[plyrX][plyrY + 1].equals(path) && !map[plyrX][plyrY + 1].equals(dugup)) {
                if (energy > 0 && canDig == true) {
                    plyrY = plyrY + 1;
                    console.setText("");
                    mg.map[plyrX][plyrY] = dugup;
                    createMapCopy();
                    printMap();
                    digLoot();
                    energy = energy - 2;
                    energyValLbl.setText(energy + "/" + maxEnergy);
                } else {
                    JOptionPane.showMessageDialog(rootPane, "You can't dig anymore, take a rest!"); // implement turn-based env.
                    canDig = false;
                }
            }
        }
    }

    private void move(char direction) {
        String message = "You cannot leave through here!";
        if (direction == 'u') {
            if (map[plyrX - 1][plyrY].equals(door)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (map[plyrX - 1][plyrY].equals(enemy)) {
                fight(plyrX - 1, plyrY);
            } else if (!detCollision(plyrX - 1, plyrY)) {
                plyrX = plyrX - 1;
                console.setText("");
                createMapCopy();
                map[plyrX][plyrY] = player;
                printMap();
            }
        } else if (direction == 'd') {
            if (map[plyrX + 1][plyrY].equals(door)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (map[plyrX + 1][plyrY].equals(enemy)) {
                fight(plyrX + 1, plyrY);
            } else if (!detCollision(plyrX + 1, plyrY)) {
                plyrX = plyrX + 1;
                console.setText("");
                createMapCopy();
                map[plyrX][plyrY] = player;
                printMap();
            }
        } else if (direction == 'l') {
            if (map[plyrX][plyrY - 1].equals(door)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (map[plyrX][plyrY - 1].equals(enemy)) {
                fight(plyrX, plyrY - 1);
            } else if (!detCollision(plyrX, plyrY - 1)) {
                plyrY = plyrY - 1;
                console.setText("");
                createMapCopy();
                map[plyrX][plyrY] = player;
                printMap();
            }
        } else if (direction == 'r') {
            if (map[plyrX][plyrY + 1].equals(door)) {
                JOptionPane.showMessageDialog(rootPane, message);
            } else if (map[plyrX][plyrY + 1].equals(enemy)) {
                fight(plyrX, plyrY + 1);
            } else if (!detCollision(plyrX, plyrY + 1)) {
                plyrY = plyrY + 1;
                console.setText("");
                createMapCopy();
                map[plyrX][plyrY] = player;
                printMap();
            }
        }
    }

    public void run() {
        while (true) {
            printMap();
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private boolean detCollision(int x, int y) {
        boolean isColliding = false;
        String obstacles[] = {mg.getSPACE(), mg.getWALL()};
        for (int i = 0; i < 2; i++) {
            if (map[x][y].equals(obstacles[i])) {
                isColliding = true;
                break;
            }
        }
        return isColliding;
    }
    
    private void placeEnemies() {
        paths = new ArrayList<>();
        for (int i = 0; i < height; i++) { // row
            for (int j = 0; j < width; j++) { // col
                if (mg.map[i][j].equals(path)){
                    paths.add(new Path(i, j));
                }
            }
        }
        int x;
        int y;
        
        for (int i = 0; i < 10; i++){
            Path temp = paths.get(Rng.rand(0, paths.size()));
            x = temp.getX();
            y = temp.getY();
            mg.map[x][y] = enemy;
        }
    }
    
    private void fight(int x, int y) {
        hp = hp - 1;
        hpValLbl.setText(hp + "/" + maxHP);
        mg.map[x][y] = path;
    }
}
